#ifndef AFD_EXPLOIT_H
#define AFD_EXPLOIT_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef _WINSOCK_DEPRECATED_NO_WARNINGS
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#endif

#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include "general.h"
#include "winring0.h"

// Memory type definitions
typedef enum _MEMORY_TYPE {
    MEMORY_TYPE_UNKNOWN = 0,
    MEMORY_TYPE_REGULAR = 1,
    MEMORY_TYPE_DEVICE = 2,
    MEMORY_TYPE_WRITECOMBINED = 3,
    MEMORY_TYPE_UNCACHED = 4,
    MEMORY_TYPE_RESERVED = 5
} MEMORY_TYPE;

// Memory access validation flags
#define MEMORY_ACCESS_READ      0x01
#define MEMORY_ACCESS_WRITE     0x02
#define MEMORY_ACCESS_EXECUTE   0x04

// Memory region context
typedef struct _MEMORY_REGION_CONTEXT {
    DWORD64 startAddress;
    DWORD64 endAddress;
    MEMORY_TYPE memoryType;
    DWORD accessFlags;
    BOOL isValid;
    BOOL isMapped;
} MEMORY_REGION_CONTEXT, *PMEMORY_REGION_CONTEXT;

// Physical memory access context
typedef struct _PHYSICAL_MEMORY_CONTEXT {
    DWORD64 physicalAddress;
    SIZE_T size;
    MEMORY_TYPE memoryType;
    BOOL isValidated;
    BOOL isSafe;
} PHYSICAL_MEMORY_CONTEXT, *PPHYSICAL_MEMORY_CONTEXT;

// CR3 access structures
typedef struct _CR3_CONTEXT {
    DWORD64 cr3;
    DWORD processId;
    BOOL isValidated;
    DWORD64 dirBase;
    DWORD64 pml4Base;
} CR3_CONTEXT, *PCR3_CONTEXT;

// AFD IOCTL codes
#define AFD_RECV_DATAGRAM_INFO 0x12023

// Pool configuration
#define POOL_HOLE_COUNT 64
#define POOL_SPRAY_COUNT 128
#define POOL_BUFFER_SIZE 0x1000

// AFD exploit functions
BOOL AdvancedAfdExploitSetup(void);
BOOL AdvancedAfdExploitTrigger(PVOID payload, SIZE_T payloadSize);
BOOL AdvancedAfdExploitCleanup(void);
BOOL ExecuteAdvancedAfdExploit(void);

// Pool manipulation functions
BOOL AfdCreatePoolHoles(void);
BOOL AfdSprayPoolObjects(void);
BOOL AfdCreateOverlappedSocket(PHANDLE socketHandle);
BOOL AfdTriggerPoolOverflow(HANDLE socketHandle, PVOID payload, SIZE_T payloadSize);
BOOL AfdFreePoolObjects(void);

// Privilege escalation functions
BOOL VerifyPrivilegeElevation(void);
BOOL CheckTokenPrivileges(void);
BOOL IsHighIntegrityLevel(void);

// Kernel access primitives (established after successful exploit)
BOOL AfdEstablishKernelAccess(void);
BOOL AfdKernelRead(DWORD64 address, PVOID buffer, SIZE_T size);
BOOL AfdKernelWrite(DWORD64 address, PVOID buffer, SIZE_T size);
BOOL AfdHasKernelAccess(void);

// Safe memory access functions
BOOL InitializePhysicalMemoryAccess(void);
BOOL ValidatePhysicalMemoryAccess(DWORD64 physicalAddress, SIZE_T size, PPHYSICAL_MEMORY_CONTEXT context);
BOOL ReadPhysicalMemorySafe(PPHYSICAL_MEMORY_CONTEXT context, PVOID buffer, SIZE_T size);
BOOL WritePhysicalMemorySafe(PPHYSICAL_MEMORY_CONTEXT context, PVOID buffer, SIZE_T size);
BOOL IsPhysicalAddressAccessible(DWORD64 physicalAddress);
MEMORY_TYPE GetMemoryType(DWORD64 physicalAddress);

// Memory validation functions
BOOL ValidateMemoryRegion(DWORD64 address, SIZE_T size, PMEMORY_REGION_CONTEXT context);
BOOL IsMemoryRegionSafe(PMEMORY_REGION_CONTEXT context);
BOOL CheckMemoryAccess(PMEMORY_REGION_CONTEXT context, DWORD requiredAccess);
BOOL IsKernelAddress(DWORD64 address);
BOOL IsUserAddress(DWORD64 address);

// Memory type checking functions
BOOL IsMemoryTypeCompatible(MEMORY_TYPE type, DWORD accessFlags);
BOOL CanReadMemoryType(MEMORY_TYPE type);
BOOL CanWriteMemoryType(MEMORY_TYPE type);
BOOL IsDeviceMemory(DWORD64 physicalAddress);
BOOL IsCacheableMemory(MEMORY_TYPE type);

// Safe CR3 access functions
BOOL GetProcessCR3Safe(DWORD processId, PCR3_CONTEXT context);
BOOL ValidateCR3(PCR3_CONTEXT context);
BOOL ValidatePageTableEntry(DWORD64 pte);
DWORD64 VirtualToPhysicalSafe(PCR3_CONTEXT context, DWORD64 virtualAddr);
BOOL ReadVirtualMemorySafe(PCR3_CONTEXT context, DWORD64 virtualAddr, PVOID buffer, SIZE_T size);
BOOL WriteVirtualMemorySafe(PCR3_CONTEXT context, DWORD64 virtualAddr, PVOID buffer, SIZE_T size);
BOOL WalkPageTablesSafe(PCR3_CONTEXT context, DWORD64 virtualAddr, PDWORD64 physicalAddr);

// I/O Ring support functions
BOOL AfdCreateIoRing(void);
BOOL AfdTriggerCVE202321768(void);
BOOL AfdVerifyKernelAccess(void);
BOOL AfdEstablishAlternativeAccess(void);
BOOL AfdCleanupIoRing(void);

// RTCore64 support functions
BOOL AfdCreateRTCoreAccess(void);
BOOL AfdTestRTCoreAccess(void);
BOOL AfdTryRTCoreRead(DWORD64 address, PVOID buffer, SIZE_T size);
BOOL AfdTryRTCoreWrite(DWORD64 address, PVOID buffer, SIZE_T size);

// RTCore64 global state
extern BOOL g_bRTCore64PrimitiveEstablished;

// RTCore64 kernel read/write functions
BOOL RTCoreKernelRead(DWORD64 Address, PVOID Buffer, DWORD Size);
BOOL RTCoreKernelWrite(DWORD64 Address, PVOID Buffer, DWORD Size);

// Driver loading/unloading functions
BOOL LoadVulnerableDriver(const char* driverPath, const char* serviceName);
BOOL UnloadVulnerableDriver(const char* serviceName);
BOOL IsUserAnAdmin(void);

// Additional vulnerable driver support
BOOL AfdTryAlternativeVulnerableDrivers(void);
BOOL TestVulnerableDriver(HANDLE driverHandle, const WCHAR* driverName);
BOOL TestDriverIOCTL(HANDLE driverHandle, DWORD ioctl);
BOOL TestVulnerableDriverAdvanced(HANDLE driverHandle, void* driverInfo);
BOOL RTCoreReadVirtualMemory(DWORD64 cr3, DWORD64 virtualAddr, PVOID buffer, DWORD size);

// Virtual-to-Physical Translation functions (RTCore64 Kernel Bypass)
DWORD64 FindProcessCR3ByPID(DWORD processId);
DWORD64 TranslateVirtualToPhysical(DWORD64 cr3, DWORD64 virtualAddr);

// GameAssembly extraction functions
BOOL ExtractGameAssemblyFromProcess(DWORD processId, DWORD64 baseAddress, const char* outputPath);
DWORD AfdFindProcessByName(const char* processName);
BOOL TestGameAssemblyExtraction(void);

#endif // AFD_EXPLOIT_H 